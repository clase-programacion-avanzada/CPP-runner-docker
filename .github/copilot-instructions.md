# CPP-Runner-Docker AI Coding Agent Instructions

## Project Overview
This is a containerized C++ development environment for educational purposes, providing consistent cross-platform compilation and execution using Docker. The system automatically detects and handles different project structures (simple files, Makefile-based, CMake-based) with robust build system support.

## Architecture & Key Components

### Core Execution Flow
1. **Entry Point**: Platform-specific scripts (`run_interactive.sh`, `run_interactive.bat`, `run_interactive.ps1`) 
2. **Container**: Ubuntu 22.04 with GCC supporting C++23 and latest CMake (4.1.1+)
3. **Build Detection**: `entrypoint.sh` automatically chooses build system with proper priority:
   - CMake projects: Runs `cmake -B build .` then `make -C build` (CMakeLists.txt detected)
   - Makefile projects: Uses `make` directly
   - Simple projects: Direct `g++ -std=c++23 -o program main.cpp`

### Docker Environment Updates
- **CMake Version**: Latest stable (4.1.1+) installed from Kitware's official repository
- **Build System**: Improved CMake detection and out-of-source builds
- **Compiler**: GCC 11.4.0 with full C++23 support

### Project Structure Convention
```
student_projects/           # Default base directory (configurable via PROJECTS_BASE_DIR)
├── project_group_X/
│   ├── main.cpp           # Default main file (configurable via MAIN_SOURCE_FILE)
│   ├── *.h/*.cpp          # Additional source files
│   ├── CMakeLists.txt     # Optional: triggers CMake build
│   ├── Makefile          # Optional: triggers make build
│   └── data files        # .txt, .csv, .dat for project data
```

## Critical Developer Workflows

### Building & Running Projects
```bash
# Standard usage
./run_interactive.sh project_group_4

# Custom project structure
PROJECTS_BASE_DIR=my_assignments MAIN_SOURCE_FILE=solution.cpp ./run_interactive.sh lab1

# Manual Docker execution for debugging
docker run --rm -it -v $(pwd)/student_projects/project_group_4:/app cpp-runner-env bash
```

### Environment Variables
- `PROJECTS_BASE_DIR`: Changes base directory from default `student_projects/`
- `MAIN_SOURCE_FILE`: Changes main file from default `main.cpp`
- Container limits: `--cpus="1.0" --memory="2g"`

### Build System Detection Logic (entrypoint.sh)
```bash
# Updated priority order with proper CMake handling:
1. CMakeLists.txt exists → run `cmake -B build .` then `make -C build`
2. Makefile/makefile exists → run `make` directly
3. Neither exists → Automatically find all .cpp files and compile with g++ -std=c++23
```

### Multi-File Compilation Improvements
- **Smart .cpp detection**: Automatically finds and compiles all .cpp files in project directory
- **Header inclusion**: Properly links .h files with their corresponding .cpp implementations
- **Undefined reference resolution**: Fixed linking issues for projects with multiple source files
- **Backward compatibility**: Still supports single-file projects as before

### CMake Integration Details
- **Out-of-source builds**: Creates `build/` directory for clean compilation
- **Executable detection**: Smart detection of executable names in build directory
- **Version compatibility**: Supports CMake 3.22+ (Ubuntu default) to 4.1.1+ (latest)
- **Build directory structure**: 
  ```
  project_directory/
  ├── CMakeLists.txt
  ├── source files...
  └── build/           # Generated by cmake -B build .
      ├── CMakeCache.txt
      ├── Makefile
      └── executable   # Found and executed automatically
  ```

## Project-Specific Patterns

### Complex Projects (project_group_4 example)
- Uses CMake with `CMAKE_CXX_STANDARD 17` and `cmake_minimum_required(VERSION 3.26)`
- Header-only architecture: `MaquinaUCI.h`, `SalaUCI.h`, `ArchivoPacientes.h`
- Binary data files: `.bsf`, `.dat` formats
- Text data: `.csv`, `.txt` for patient/sensor data
- Main executable: `Talleres_Proyecto` (not default "program")
- **Build process**: Uses out-of-source build in `build/` directory
- **Function implementations**: Complete implementations in `funciones.cpp` for all declared functions

### Simple Projects (project_group_1 example)  
- Single `main.cpp` file
- Modern C++ features: `std::vector`, range-based loops
- No external dependencies beyond standard library

### Multi-File Projects (project_group_2 example)
- Multiple source files: `main.cpp`, `calculator.cpp`, `calculator.h`
- Class-based architecture with separate implementation files
- Automatic multi-file compilation via improved g++ detection
- Header guards and proper include structure
- **Build process**: Automatically detects and compiles all .cpp files together

### CMake Projects (project_group_3 example)
- Complex build configuration with `CMakeLists.txt`
- Multiple modules: `main.cpp`, `math_utils.cpp`, `string_utils.cpp`
- Namespace organization and utility libraries
- Custom executable naming and build definitions
- **Build process**: Uses out-of-source build in `build/` directory

### File Organization Conventions
- **Headers**: Use `.h` extension, include guards
- **Data files**: Keep alongside source in project directory
- **Build outputs**: Generated in project root (not subdirectories) or `build/` for CMake projects
- **Naming**: Spanish names common (educational context)
- **CMake projects**: Source files explicitly listed in `CMakeLists.txt`
- **Multi-file projects**: All .cpp files automatically detected and compiled together

## Testing & Validation

### Test Project Structure
The project includes comprehensive test cases to validate different compilation scenarios:

#### project_group_1: Simple Single-File Project
- Single `main.cpp` with no dependencies
- Tests basic g++ compilation workflow

#### project_group_2: Multi-File Project (Header + Implementation)
- `main.cpp` - Main program using calculator functions
- `calculator.h` - Header with class and function declarations
- `calculator.cpp` - Implementation of calculator functions
- **Tests**: Multi-file g++ compilation, undefined reference resolution, automatic .cpp detection

#### project_group_3: CMake Project with Multiple Modules
- `CMakeLists.txt` - CMake configuration with C++23 standard
- `main.cpp` - Main program testing utility libraries
- `math_utils.h/cpp` - Mathematical utility functions with namespace
- `string_utils.h/cpp` - String manipulation utilities with namespace
- **Tests**: CMake build system, out-of-source builds, executable detection, complex project structure

## Cross-Platform Compatibility

### Script Equivalence
All three scripts (`*.sh`, `*.bat`, `*.ps1`) perform identical Docker operations:
- Windows users: Prefer PowerShell (`.ps1`) > Batch (`.bat`) > Bash (`.sh`)
- Unix systems: Use `.sh` exclusively
- All support same environment variables with platform-specific syntax

### Container Constraints
- **Memory**: 2GB limit enforced
- **CPU**: 1.0 CPU limit
- **Network**: No external network access during execution
- **Filesystem**: Only project directory mounted to `/app`

## Common Integration Points

### Volume Mounting Pattern
```bash
# Host project directory → Container /app
-v "$(pwd)/$PROJECT_PATH":/app
```

### Data File Handling
Projects often include:
- Configuration files: `configuracion.txt`, `config.ini`
- Patient/sensor data: `mediciones_paciente_*.txt`
- Binary formats: Custom `.bsf` (binary sensor format)
- CSV data: `pacientes.csv`

### Error Handling
- Compilation failures: Exit code 1, detailed G++ output
- Missing files: Warning but attempt compilation anyway  
- Runtime errors: Program output preserved in container logs

## Development Workflow Specifics

### Iterative Development
1. Edit source files in host IDE
2. Run `./run_interactive.sh project_name` 
3. Container auto-compiles and executes
4. Output/errors displayed immediately
5. Container cleanup automatic (`--rm` flag)

### Debugging Approach
```bash
# Interactive shell for investigation
docker run --rm -it -v $(pwd)/student_projects/project_name:/app cpp-runner-env bash

# Inside container:
ls -la                    # Check file permissions
cmake -B build .         # Configure CMake project (if CMakeLists.txt exists)
make -C build            # Build CMake project
make                     # Build Makefile project
./program               # Manual execution (simple projects)
./build/executable      # Manual execution (CMake projects)
```

### Adding New Projects
1. Create directory under `student_projects/` (or custom base)
2. Add `main.cpp` (or custom main file)
3. Optional: Add `Makefile` or `CMakeLists.txt` for complex builds
4. Run with appropriate script for platform

## Recent Improvements & Troubleshooting

### Multi-File Compilation Fix (September 2025)
- **Problem Solved**: Projects with .h/.cpp file combinations no longer fail with undefined reference errors
- **Implementation**: Enhanced `entrypoint.sh` to automatically detect and compile all .cpp files when no Makefile/CMake exists
- **Validation**: Comprehensive test cases in project_group_2 (multi-file) and project_group_3 (CMake)
- **Backward Compatibility**: Single-file projects continue to work as before

### CMake Integration Fixes (September 2025)
- **Fixed CMake detection**: `entrypoint.sh` now properly runs `cmake -B build .` before `make -C build`
- **Out-of-source builds**: All CMake projects now build in `build/` directory for cleaner organization
- **Executable detection**: Smart detection finds the correct executable name in build directory
- **Version compatibility**: Updated Docker image includes CMake 4.1.1+ from Kitware's official repository

### Common Issues & Solutions

#### Multi-File Compilation Issues (RESOLVED)
- **Problem**: Functions declared in headers but implemented in separate .cpp files caused undefined reference errors
- **Solution**: Enhanced g++ compilation to automatically find and compile all .cpp files in project directory
- **Test Case**: project_group_2 validates this fix with calculator.h/calculator.cpp structure

#### CMake Version Mismatch
- **Problem**: CMakeLists.txt requires newer CMake than container provides
- **Solution**: Either update CMakeLists.txt to use compatible version, or rebuild Docker image with latest CMake

#### Undefined Reference Errors
- **Problem**: Functions declared in headers but not implemented
- **Solution**: Ensure all source files are listed in CMakeLists.txt or Makefile, or use the automatic g++ multi-file detection

#### Build Directory Issues
- **Problem**: Previous builds interfering with current compilation
- **Solution**: CMake projects now use clean out-of-source builds in `build/` directory

### Docker Image Updates
The Dockerfile now installs CMake from Kitware's official repository:
```dockerfile
# Install latest CMake from Kitware's official repository
wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | gpg --dearmor - | tee /etc/apt/trusted.gpg.d/kitware.gpg >/dev/null && \
echo 'deb https://apt.kitware.com/ubuntu/ jammy main' | tee /etc/apt/sources.list.d/kitware.list >/dev/null && \
apt-get update && \
apt-get install -y cmake
```

### Entrypoint.sh Multi-File Detection
The enhanced `entrypoint.sh` now includes smart .cpp file detection for projects without build files:
```bash
# Find all .cpp files and compile them together
CPP_FILES=$(find . -name "*.cpp" -type f)
if [ -n "$CPP_FILES" ]; then
    g++ -std=c++23 -o "$OUTPUT_BINARY" $CPP_FILES
else
    g++ -std=c++23 -o "$OUTPUT_BINARY" "$SOURCE_FILE"
fi
```
This resolves the common "undefined reference" errors when using multiple .cpp/.h file combinations.
