# CPP-Runner-Docker AI Coding Agent Instructions

## Project Overview
This is a containerized C++ development environment for educational purposes, providing consistent cross-platform compilation and execution using Docker. The system automatically detects and handles different project structures (simple files, Makefile-based, CMake-based) with robust build system support.

## Architecture & Key Components

### Core Execution Flow
1. **Entry Point**: Platform-specific scripts (`run_interactive.sh`, `run_interactive.bat`, `run_interactive.ps1`) 
2. **Container**: Ubuntu 22.04 with GCC supporting C++23 and latest CMake (4.1.1+)
3. **Build Detection**: `entrypoint.sh` automatically chooses build system with proper priority:
   - CMake projects: Runs `cmake -B build .` then `make -C build` (CMakeLists.txt detected)
   - Makefile projects: Uses `make` directly
   - Simple projects: Direct `g++ -std=c++23 -o program main.cpp`

### Docker Environment Updates
- **CMake Version**: Latest stable (4.1.1+) installed from Kitware's official repository
- **Build System**: Improved CMake detection and out-of-source builds
- **Compiler**: GCC 11.4.0 with full C++23 support

### Project Structure Convention
```
student_projects/           # Default base directory (configurable via PROJECTS_BASE_DIR)
├── project_group_X/
│   ├── main.cpp           # Default main file (configurable via MAIN_SOURCE_FILE)
│   ├── *.h/*.cpp          # Additional source files
│   ├── CMakeLists.txt     # Optional: triggers CMake build
│   ├── Makefile          # Optional: triggers make build
│   └── data files        # .txt, .csv, .dat for project data
```

## Critical Developer Workflows

### Building & Running Projects
```bash
# Standard usage
./run_interactive.sh project_group_4

# Custom project structure
PROJECTS_BASE_DIR=my_assignments MAIN_SOURCE_FILE=solution.cpp ./run_interactive.sh lab1

# Manual Docker execution for debugging
docker run --rm -it -v $(pwd)/student_projects/project_group_4:/app cpp-runner-env bash
```

### Environment Variables
- `PROJECTS_BASE_DIR`: Changes base directory from default `student_projects/`
- `MAIN_SOURCE_FILE`: Changes main file from default `main.cpp`
- Container limits: `--cpus="1.0" --memory="2g"`

### Build System Detection Logic (entrypoint.sh)
```bash
# Updated priority order with proper CMake handling:
1. CMakeLists.txt exists → run `cmake -B build .` then `make -C build`
2. Makefile/makefile exists → run `make` directly
3. Neither exists → g++ -std=c++23 -o program $SOURCE_FILE
```

### CMake Integration Details
- **Out-of-source builds**: Creates `build/` directory for clean compilation
- **Executable detection**: Smart detection of executable names in build directory
- **Version compatibility**: Supports CMake 3.22+ (Ubuntu default) to 4.1.1+ (latest)
- **Build directory structure**: 
  ```
  project_directory/
  ├── CMakeLists.txt
  ├── source files...
  └── build/           # Generated by cmake -B build .
      ├── CMakeCache.txt
      ├── Makefile
      └── executable   # Found and executed automatically
  ```

## Project-Specific Patterns

### Complex Projects (project_group_4 example)
- Uses CMake with `CMAKE_CXX_STANDARD 17` and `cmake_minimum_required(VERSION 3.26)`
- Header-only architecture: `MaquinaUCI.h`, `SalaUCI.h`, `ArchivoPacientes.h`
- Binary data files: `.bsf`, `.dat` formats
- Text data: `.csv`, `.txt` for patient/sensor data
- Main executable: `Talleres_Proyecto` (not default "program")
- **Build process**: Uses out-of-source build in `build/` directory
- **Function implementations**: Complete implementations in `funciones.cpp` for all declared functions

### Simple Projects (project_group_1 example)  
- Single `main.cpp` file
- Modern C++ features: `std::vector`, range-based loops
- No external dependencies beyond standard library

### File Organization Conventions
- **Headers**: Use `.h` extension, include guards
- **Data files**: Keep alongside source in project directory
- **Build outputs**: Generated in project root (not subdirectories) or `build/` for CMake projects
- **Naming**: Spanish names common (educational context)
- **CMake projects**: Source files explicitly listed in `CMakeLists.txt`

## Cross-Platform Compatibility

### Script Equivalence
All three scripts (`*.sh`, `*.bat`, `*.ps1`) perform identical Docker operations:
- Windows users: Prefer PowerShell (`.ps1`) > Batch (`.bat`) > Bash (`.sh`)
- Unix systems: Use `.sh` exclusively
- All support same environment variables with platform-specific syntax

### Container Constraints
- **Memory**: 2GB limit enforced
- **CPU**: 1.0 CPU limit
- **Network**: No external network access during execution
- **Filesystem**: Only project directory mounted to `/app`

## Common Integration Points

### Volume Mounting Pattern
```bash
# Host project directory → Container /app
-v "$(pwd)/$PROJECT_PATH":/app
```

### Data File Handling
Projects often include:
- Configuration files: `configuracion.txt`, `config.ini`
- Patient/sensor data: `mediciones_paciente_*.txt`
- Binary formats: Custom `.bsf` (binary sensor format)
- CSV data: `pacientes.csv`

### Error Handling
- Compilation failures: Exit code 1, detailed G++ output
- Missing files: Warning but attempt compilation anyway  
- Runtime errors: Program output preserved in container logs

## Development Workflow Specifics

### Iterative Development
1. Edit source files in host IDE
2. Run `./run_interactive.sh project_name` 
3. Container auto-compiles and executes
4. Output/errors displayed immediately
5. Container cleanup automatic (`--rm` flag)

### Debugging Approach
```bash
# Interactive shell for investigation
docker run --rm -it -v $(pwd)/student_projects/project_name:/app cpp-runner-env bash

# Inside container:
ls -la                    # Check file permissions
cmake -B build .         # Configure CMake project (if CMakeLists.txt exists)
make -C build            # Build CMake project
make                     # Build Makefile project
./program               # Manual execution (simple projects)
./build/executable      # Manual execution (CMake projects)
```

### Adding New Projects
1. Create directory under `student_projects/` (or custom base)
2. Add `main.cpp` (or custom main file)
3. Optional: Add `Makefile` or `CMakeLists.txt` for complex builds
4. Run with appropriate script for platform

## Recent Improvements & Troubleshooting

### CMake Integration Fixes (September 2025)
- **Fixed CMake detection**: `entrypoint.sh` now properly runs `cmake -B build .` before `make -C build`
- **Out-of-source builds**: All CMake projects now build in `build/` directory for cleaner organization
- **Executable detection**: Smart detection finds the correct executable name in build directory
- **Version compatibility**: Updated Docker image includes CMake 4.1.1+ from Kitware's official repository

### Common Issues & Solutions

#### CMake Version Mismatch
- **Problem**: CMakeLists.txt requires newer CMake than container provides
- **Solution**: Either update CMakeLists.txt to use compatible version, or rebuild Docker image with latest CMake

#### Undefined Reference Errors
- **Problem**: Functions declared in headers but not implemented
- **Solution**: Ensure all source files are listed in CMakeLists.txt or Makefile

#### Build Directory Issues
- **Problem**: Previous builds interfering with current compilation
- **Solution**: CMake projects now use clean out-of-source builds in `build/` directory

### Docker Image Updates
The Dockerfile now installs CMake from Kitware's official repository:
```dockerfile
# Install latest CMake from Kitware's official repository
wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | gpg --dearmor - | tee /etc/apt/trusted.gpg.d/kitware.gpg >/dev/null && \
echo 'deb https://apt.kitware.com/ubuntu/ jammy main' | tee /etc/apt/sources.list.d/kitware.list >/dev/null && \
apt-get update && \
apt-get install -y cmake
```
